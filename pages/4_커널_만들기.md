# 커널 만들기
커널은 운영체제의 핵심으로, 하드웨어와 소프트웨어 간의 상호작용을 관리합니다.

## 오늘 작업 설명
> ---
> 부트로더는 운영체제가 시작하면 가장 먼저 실행되기 때문에 hello world를 출력시켰고 부트로더 다음은 커널이 작동되는데 커널의 작동 여부를 확인하고자 kernel이라는 단어를 출력시키면서 두 프로그램이 잘 연결된다는 것을 확인한 과정
> ---


## 쉬운설명
1. 부트로더 작성
> 컴퓨터야 이제 운영체제를 실행하자!

운영체제를 실행하려면 컴퓨터가 처음 켜졌을 때 가장 먼저 해야 할 일을 알려줄 **부트로더**가 필요해요. 부트로더는 운영체제가 메모리에 로드되기 전에 컴퓨터가 무엇을 해야 할지 지시하는 작은 프로그램이에요.

<br>

우리는 부트로더에 "Hello World!"라는 메시지를 출력하라고 했고, 그 다음으로 커널을 메모리에 로드한 후 커널로 점프하도록 했어요.


2. 커널 작성
> 커널은 컴퓨터의 두뇌와 같아서 모든 자원을 관리하고 명령을 내려요.

커널은 컴퓨터가 켜지면 모든 것을 제어하게 해줘요. 메모리, CPU, 그리고 하드웨어 장치를 관리하고 프로그램들이 실행되도록 도와줘요.

<br>

오늘은 커널이 간단히 'Kernel'이라는 단어를 화면에 출력하는 것이었습니다.


3. 링커 스크립트 작성
> 커널이 메모리의 정확히 어디에 로드될까?를 결정해준다. 

부트로더와 커널은 각기 다른 프로그램인데, 이 둘을 메모리 **어디에 로드할지** 지정해주는 역할을 해요

<br>

오늘은 메모리의 0x1000이라는 주소에 로드되도록 설정했습니다.

4. 부트로더 + 커널 = 디스크 이미지
> 부트로더 + 커널을 합쳐서 컴퓨터가 이 파일을 실행할 수 있도록 한다.

두 파일을 따로 실행할 수 없어서, 두 파일을 하나로 합쳐서 디스크 이미지(os.img)를 만들었습니다.


5. QEMU로 부팅해서 테스트
> QEMU는 가상 컴퓨터고, 우리가 만든 부트로더와 커널을 이 가상 컴퓨터에서 실행해보는 겁니다.

QEMU는 실제 컴퓨터를 시뮬레이션해주는 프로그램이에요. 우리는 이 프로그램을 사용해 os.img 파일을 불러와서 실제 컴퓨터처럼 부팅해봤습니다.


## 기본 설명
1. 부트로더 작성 및 컴파일(boot.asm)
   - 부트로더를 작성하여 "Hello World" 메시지를 출력하고, 이후 커널을 디스크에서 메모리로 로드한 후 커널로 점프하는 기능을 구현했습니다.
   - **NASM**을 사용하여 부트로더 코드를 `boot.bin`으로 컴파일했습니다.
2. 커널 코드 작성 및 컴파일(kernel.c)
   - 칸단한 커널 코드를 작성하여 화면에 "Kernel" 메시지를 출력하는 기능을 구현했습니다.
   - **GCC**를 사용하여 커널 C 코드를 `kernel.o` 오브젝트 파일로 컴파일했습니다.

3. 링커 스크립트 작성(linker.ld)
   - 커널이 메모리의 0x1000 주소에 로드되도록하는 링커 스크립트를 작성했습니다.
   - **LD** 명령어를 사용해 링커 스크립트를 통해 `kernel.o`를 `kernel.bin`으로 변환하여 커널 바이너리 파일을 생성했습니다.

4. 부트로더와 커널 결합 (os.img)
   - **dd 명령어**를 사용하여 부트로더와 커널을 하나의 디스크 이미지(`os.img`)로 결합했습니다.
   - 부트로더는 디스크 이미지의 첫 번째 섹터에, 커널은 그 이후 섹터에 기록하여 하나의 부팅 가능한 이미지를 생성했습니다.

5. QEMU를 통해 부팅 및 테스트
   - **QEMU**를 사용해 디스크 이미지로 부팅을 시도했습니다.